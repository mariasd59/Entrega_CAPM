# -*- coding: utf-8 -*-
"""final_capm_dashboard.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s1A1jelxEGMcD7r5cdof5wjOnrIEvE-u
"""

pip install streamlit

import yfinance as yf
import datetime
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import streamlit as st
from scipy.stats import norm
from scipy.optimize import minimize

st.set_page_config(layout="wide")
st.title(" Dashboard Financiero: Portafolio ptimo 25%")

# Par谩metros
symbols = ['VTI', 'SPHD', 'AAPL', 'JNJ', 'KO', 'PG', 'MSFT', 'PEP', 'GC=F', 'KC=F']
target_return = 0.25
today = datetime.date.today()
start_date = today - datetime.timedelta(days=365)

# 1. Descarga de precios
prices = yf.download(symbols, start=start_date, end=today)['Close']
st.subheader("Precios hist贸ricos")
st.line_chart(prices)

# 2. Retornos
returns = prices.pct_change().dropna()
mu_daily = returns.mean()
cov_daily = returns.cov()
mu_annual = mu_daily * 250
cov_annual = cov_daily * 250

# 3. Optimizaci贸n
n = len(symbols)
initial_w = np.ones(n) / n
bounds = [(0.01, 1) for _ in symbols]
constraints = [
    {'type': 'eq', 'fun': lambda w: np.sum(w) - 1},
    {'type': 'eq', 'fun': lambda w: np.dot(w, mu_annual) - target_return}
]
def portfolio_variance(w):
    return np.dot(w, np.dot(cov_annual, w))

res = minimize(portfolio_variance, x0=initial_w, bounds=bounds, constraints=constraints)
w_target = res.x
ret_target = np.dot(w_target, mu_annual)
vol_target = np.sqrt(np.dot(w_target, np.dot(cov_annual, w_target)))
sharpe_target = ret_target / vol_target

# 4. Pesos 贸ptimos
st.subheader("Pesos 贸ptimos del portafolio")
df_pesos = pd.DataFrame({'Activo': symbols, 'Peso (%)': w_target * 100})
st.dataframe(df_pesos.set_index('Activo').style.format("{:.2f}"))

# 5. VaR Monte Carlo
ret_pf_daily = returns.dot(w_target)
simulations = np.random.default_rng(42).multivariate_normal(mu_daily, cov_daily, size=10000).dot(w_target)
var95_mc = np.percentile(simulations, 5)

# Histograma + KDE
st.subheader("Distribuci贸n de retornos diarios del portafolio")
fig, ax = plt.subplots()
ax.hist(ret_pf_daily, bins=40, density=True, alpha=0.6, label='Histograma')
pd.Series(ret_pf_daily).plot(kind='kde', ax=ax, label='KDE')
ax.axvline(ret_pf_daily.mean(), color='black', linestyle='--', label='Media')
ax.axvline(-var95_mc, color='red', linestyle='-', label='VaR 95% MC')
ax.set_title("Distribuci贸n de retornos diarios")
ax.legend()
ax.grid(True)
st.pyplot(fig)

# 6. Simulaci贸n GBM
st.subheader("Simulaci贸n GBM (6 meses)")
n_days = 125
n_sims = 100
渭 = ret_pf_daily.mean()
 = ret_pf_daily.std()
drift = 渭 - 0.5 * **2
Z = np.random.default_rng(42).standard_normal(size=(n_days, n_sims))
paths = np.exp(drift +  * Z).cumprod(axis=0)

fig2, ax2 = plt.subplots(figsize=(8,4))
for i in range(n_sims):
    ax2.plot(paths[:, i], lw=1, alpha=0.5)
ax2.set_title("Trayectorias GBM del portafolio")
ax2.set_xlabel("D铆a")
ax2.set_ylabel("Factor acumulado")
ax2.grid(True)
st.pyplot(fig2)

# 7. Resultados clave
st.subheader("Resumen del portafolio")
col1, col2, col3 = st.columns(3)
col1.metric("Rentabilidad esperada", f"{ret_target:.2%}")
col2.metric("Volatilidad anual", f"{vol_target:.2%}")
col3.metric("Sharpe Ratio", f"{sharpe_target:.2f}")

# 8. VaR param茅trico
mean_daily = ret_pf_daily.mean()
std_daily = ret_pf_daily.std()
var95_d = norm.ppf(0.05, mean_daily, std_daily)
var99_d = norm.ppf(0.01, mean_daily, std_daily)
var95_w = norm.ppf(0.05, mean_daily*5, std_daily*np.sqrt(5))
var99_w = norm.ppf(0.01, mean_daily*5, std_daily*np.sqrt(5))
var95_m = norm.ppf(0.05, mean_daily*21, std_daily*np.sqrt(21))
var99_m = norm.ppf(0.01, mean_daily*21, std_daily*np.sqrt(21))

st.subheader("VaR param茅trico")
st.write(f"**Diario**  |  VaR 95%: {var95_d:.4%}  |  VaR 99%: {var99_d:.4%}")
st.write(f"**Semanal** |  VaR 95%: {var95_w:.4%}  |  VaR 99%: {var99_w:.4%}")
st.write(f"**Mensual** |  VaR 95%: {var95_m:.4%}  |  VaR 99%: {var99_m:.4%}")

# 9. CAPM - Beta
benchmark = '^GSPC'
benchmark_prices = yf.download(benchmark, start=start_date, end=today)['Close']
benchmark_returns = benchmark_prices.pct_change().dropna()
aligned_returns = pd.concat([ret_pf_daily, benchmark_returns], axis=1).dropna()
aligned_returns.columns = ['portfolio', 'benchmark']
cov_matrix = np.cov(aligned_returns['portfolio'], aligned_returns['benchmark'])
beta = cov_matrix[0, 1] / cov_matrix[1, 1]

st.subheader("CAPM")
st.metric("Beta del portafolio (vs S&P 500)", f"{beta:.4f}")